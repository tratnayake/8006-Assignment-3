{
  "name": "async-arrays",
  "homepage": "https://github.com/khrome/async-arrays",
  "version": "0.3.0",
  "main": "async-arrays.js",
  "description": "Async control for arrays",
  "keywords": [
    "array",
    "async"
  ],
  "author": {
    "name": "Abbey Hawk Sparrow",
    "email": "@khrome",
    "url": "http://patternweaver.com"
  },
  "contributors": [],
  "bugs": {
    "url": "https://github.com/khrome/async-arrays/issues"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git://github.com/khrome/async-arrays.git"
  },
  "dependencies": {
    "sift": "*"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "readme": "async-arrays.js\n===============\n\nprototype extensions for Array when using that data asynchronously, with utilities from prime-ext\n\nUsage\n-----\nI find, most of the time, my asynchronous logic emerges from an array and I really just want to be able to control the completion of some job, and have a signal for all jobs. In many instances, this winds up being more versatile than a promise which limits you to a binary state and only groups returns according to it's state. \n\nyou can either retain an instance and use it that way:\n\n    var arrayTool = require('async-arrays');\n    arrayTool.forEachEmission(array, iterator, calback);\n    \nor you can just attach to the prototype:\n\n    require('async-arrays').proto();\n\nforEachEmission : execute serially\n\n    [].forEachEmission(function(item, index, done){\n        somethingAsynchronous(function(){\n            done();\n        });\n    }, function(){\n        //we're all done!\n    });\n    \nforAllEmissions : execute all jobs in parallel\n\n    [].forAllEmissions(function(item, index, done){\n        somethingAsynchronous(function(){\n            done();\n        });\n    }, function(){\n        //we're all done!\n    });\n    \nforAllEmissionsInPool : execute all jobs in parallel up to a maximum #, then queue for later\n\n    [].forAllEmissionsInPool(poolSize, function(item, index, done){\n        somethingAsynchronous(function(){\n            done();\n        });\n    }, function(){\n        //we're all done!\n    });\n    \nUtility functions(not mutators):\n\n    ['dog', 'cat', 'mouse'].contains('cat') //returns true;\n\n    ['dog', 'cat'].combine(['mouse']) //returns ['dog', 'cat', 'mouse'];\n    \n    ['dog', 'cat', 'mouse'].erase('cat') //returns ['dog', 'mouse'];\n    \n\nThat's just about it, and even better you can open up the source and check it out yourself. Super simple.\n\nTesting\n-------\njust run\n    \n    mocha\n\nEnjoy,\n\n-Abbey Hawk Sparrow",
  "readmeFilename": "README.md",
  "_id": "async-arrays@0.3.0",
  "_from": "async-arrays@*"
}
